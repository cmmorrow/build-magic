{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"build-magic \ud83d\udd28\u2728 \u00b6 An un-opinionated, build automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It runs anywhere and is designed to be easy to use by both developers and DevOps engineers. Using build-magic can be as simple as: > build-magic echo hello world! or can support complex build automation with multiple steps on the command-line or in a Config File. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --action cleanup \\ --command install \"apt update && apt install gcc\" \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz dist/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File > build-magic -C myapp.yaml > cat myapp.yaml build-magic : - stage : runner : docker environment : ubuntu:latest action : cleanup commands : - install : apt update && apt install gcc - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz dist/* - release : jfrog rt upload myapp.tar.gz my-artifactory Build-magic can execute a batch of commands in a Config File with: > build-magic -C myapp.yaml Or, if the Config File is named build-magic.yaml , can be run similar to a Makefile with: > build-magic release Common Use Cases \u00b6 Automate building, testing, and releasing new software versions. Build and deploy new machine learning models. Automate deploying software to staging or production cloud environments. Simplify onboarding new team members by automating development environment setup and installation. Automate launching an application for local testing with the same Config File used for deploying in production. Execute regression, integration, and unit tests across multiple platforms and servers. Automate dry runs of critical commands that cannot be tested on a production system. Features \u00b6 Builds that work for you \u00b6 Developing for Linux from a Windows or MacOS laptop? Build-magic lets you build, test, and deploy your application within a Docker container, virtual machine, or on a remote machine. Build-magic will manage the environment differences for you so you can focus on the details that matter. Automate everything \u00b6 If your terminal can do it, build-magic can automate it! Build-magic is a modern alternative to automating with Makefiles and shell scripts. Build-magic Config Files feature an easy to use YAML syntax for executing multiple stages (targets). Build-magic actions can also apply setup and teardown behaviors for preserving container or VM state, or clean up extra files generated as part of a build process. Build-magic also gives you control over how output is displayed by providing a TTY friendly format as well a log file friendly format. Simple but powerful \u00b6 There are no looping mechanics or specialized conditional logic directives beyond what can be done via the command-line. This might seem like a disadvantage but it makes build-magic jobs easier to debug, re-run, and reproduce. What build-magic lacks in programming language-like features, it makes up for with easy of use and powerful actions. By using the cleanup action, build-magic jobs can become idempotent. The persist action will preserve the state of a container or VM after execution of a job. Un-opinionated \u00b6 As much as possible, build-magic strives to setup environments and execute commands the same way, whether commands are being executed locally, remotely, in a container, or in a VM. Also, unlike similar automation tools that have builtin directives, build-magic command directives don't impart any special meaning or track state -- they are simply descriptive. This keeps things simple, and what you see in a build-magic Config File or in command-line arguments is exactly what's executed. Aside from the simple syntax, build-magic doesn't care how you run commands. Runtime variables \u00b6 Build-magic Config Files support placeholders using a template syntax. At runtime, dynamic values and secrets can be assigned and substituted for the placeholders, allowing for general-purpose, multi-user use cases. Simplify onboarding a new team member by automating project setup with a single build-magic Config File. Need static variables available at runtime? Environment variables can be selectively applied to a group of commands. Cross platform \u00b6 Build-magic runs on Windows, Mac OS, and Linux. For ultimate portability, build-magic supports executing commands on a remote server via SSH, in a Docker container, or in a virtual machine via Vagrant. Have some commands that can only run on Windows? Simply mark a stage as Windows only and the associated commands will be skipped on other platforms. Also, build-magic Config Files support variable substitution so dynamic values like version numbers and credentials can be supplied at runtime and substituted into commands.","title":"Home"},{"location":"#build-magic","text":"An un-opinionated, build automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It runs anywhere and is designed to be easy to use by both developers and DevOps engineers. Using build-magic can be as simple as: > build-magic echo hello world! or can support complex build automation with multiple steps on the command-line or in a Config File. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --action cleanup \\ --command install \"apt update && apt install gcc\" \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz dist/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File > build-magic -C myapp.yaml > cat myapp.yaml build-magic : - stage : runner : docker environment : ubuntu:latest action : cleanup commands : - install : apt update && apt install gcc - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz dist/* - release : jfrog rt upload myapp.tar.gz my-artifactory Build-magic can execute a batch of commands in a Config File with: > build-magic -C myapp.yaml Or, if the Config File is named build-magic.yaml , can be run similar to a Makefile with: > build-magic release","title":"build-magic &#x1F528;&#x2728;"},{"location":"#common-use-cases","text":"Automate building, testing, and releasing new software versions. Build and deploy new machine learning models. Automate deploying software to staging or production cloud environments. Simplify onboarding new team members by automating development environment setup and installation. Automate launching an application for local testing with the same Config File used for deploying in production. Execute regression, integration, and unit tests across multiple platforms and servers. Automate dry runs of critical commands that cannot be tested on a production system.","title":"Common Use Cases"},{"location":"#features","text":"","title":"Features"},{"location":"#builds-that-work-for-you","text":"Developing for Linux from a Windows or MacOS laptop? Build-magic lets you build, test, and deploy your application within a Docker container, virtual machine, or on a remote machine. Build-magic will manage the environment differences for you so you can focus on the details that matter.","title":"Builds that work for you"},{"location":"#automate-everything","text":"If your terminal can do it, build-magic can automate it! Build-magic is a modern alternative to automating with Makefiles and shell scripts. Build-magic Config Files feature an easy to use YAML syntax for executing multiple stages (targets). Build-magic actions can also apply setup and teardown behaviors for preserving container or VM state, or clean up extra files generated as part of a build process. Build-magic also gives you control over how output is displayed by providing a TTY friendly format as well a log file friendly format.","title":"Automate everything"},{"location":"#simple-but-powerful","text":"There are no looping mechanics or specialized conditional logic directives beyond what can be done via the command-line. This might seem like a disadvantage but it makes build-magic jobs easier to debug, re-run, and reproduce. What build-magic lacks in programming language-like features, it makes up for with easy of use and powerful actions. By using the cleanup action, build-magic jobs can become idempotent. The persist action will preserve the state of a container or VM after execution of a job.","title":"Simple but powerful"},{"location":"#un-opinionated","text":"As much as possible, build-magic strives to setup environments and execute commands the same way, whether commands are being executed locally, remotely, in a container, or in a VM. Also, unlike similar automation tools that have builtin directives, build-magic command directives don't impart any special meaning or track state -- they are simply descriptive. This keeps things simple, and what you see in a build-magic Config File or in command-line arguments is exactly what's executed. Aside from the simple syntax, build-magic doesn't care how you run commands.","title":"Un-opinionated"},{"location":"#runtime-variables","text":"Build-magic Config Files support placeholders using a template syntax. At runtime, dynamic values and secrets can be assigned and substituted for the placeholders, allowing for general-purpose, multi-user use cases. Simplify onboarding a new team member by automating project setup with a single build-magic Config File. Need static variables available at runtime? Environment variables can be selectively applied to a group of commands.","title":"Runtime variables"},{"location":"#cross-platform","text":"Build-magic runs on Windows, Mac OS, and Linux. For ultimate portability, build-magic supports executing commands on a remote server via SSH, in a Docker container, or in a virtual machine via Vagrant. Have some commands that can only run on Windows? Simply mark a stage as Windows only and the associated commands will be skipped on other platforms. Also, build-magic Config Files support variable substitution so dynamic values like version numbers and credentials can be supplied at runtime and substituted into commands.","title":"Cross platform"},{"location":"CHANGELOG/","text":"What's New \u00b6 Version 0.5.1 (Newest) \u00b6 Fixed a cleanup action bug that prevented existing empty directories from being deleted. Updated paramiko to 2.10.1. Version 0.5.0 \u00b6 Added the --skip switch to manually skip named stages. Added the current working directory to stdout. Fixed a regression bug that caused the bind and hostwd parameters to fail validation. Fixed a bug introduced in 0.4.1 that would delete existing directories when the cleanup action was used. Version 0.4.1 \u00b6 Updated python packages. Fixed a cleanup action bug on Windows that prevented directories mis-identified as files from preventing cleanup. Fixed a cleanup action bug that prevented files in an empty working directory from being cleaned up. Fixed a cleanup action bug that prevented an empty directory from being deleted. Fixed a bug that would raise an unhandled exception if a Windows path was provided as a runtime variable. Fixed a cleanup action bug on Windows with the remote command runner. Version 0.4.0 \u00b6 Added a prep section to config files. Added author, maintainer, version, created, and modified sections to config files. Added the --info option to the CLI for viewing config file meta data. Added dotenv file support. Added support for environment variables. Added support for command labels to optionally display instead of the command itself. Added support for job and stage descriptions. An environment can now be specified for the Local command runner and the stage will be skipped if the environment doesn't match the current OS or distribution. Build-magic creates and uses a custom Vagrantfile when using the Vagrant command runner and setting bind directory or envvars. Bugfixes Version 0.3.3 \u00b6 Fixed a bug where an error when parsing a YAML file was not caught and handled. Code cleanup and style enforcement with Flake8. Version 0.3.2 \u00b6 Updated dependencies to newer versions. Version 0.3.1 \u00b6 Updated dependency versions. Improved the error message when Docker or Vagrant isn't installed. Fixed a bug that caused the spinner to continue running if the environment is a Docker container that cannot be found. Improved error handling in the case a Docker container cannot be found. Added a check for if a build-magic container is already running and raises an exception if so. Added a check to make sure the provided host working directory exists for the Docker and Vagrant runners. Version 0.3.0 \u00b6 Added the --template option for generating an example Config File named build-magic_template.yaml. Added support for variable substitution in Config Files using the syntax {{ VARIABLE }} which can be substituted with myhost by using the command-line option --variable VARIABLE myhost . Added the --prompt option to interactively prompt the user for a value to substitute with --prompt VARIABLE . Fixed a bug in the cleanup action that caused directories to not be properly deleted on Windows. Fixed a bug where open default config files were not being properly closed on Windows. Fixed a bug affecting commands displayed that are too long for the terminal or end in a new line character. Fixed a bug where the spinner continued to run after a keyboard interrupt was received. Fixed a bug where using the cleanup action on Windows would cause a job to fail on startup if a file or directory raised a permission error. Fixed a bug that prevented stderr from a command executed in a Docker container from being displayed properly. Version 0.2.0 \u00b6 Added the --target and -t options to execute specific config file stages by name. Added the ability to run specific config file stages by name passed as an argument if the config file has a default name of build-magic.yaml. Added a process spinner to long-running stage start up commands. Added the sequence number and total commands to the output for each command. Removed the newline character at the end of the output displayed when in verbose mode. Changed the stage end status from COMPLETE to DONE. Version 0.1.1 \u00b6 Added the hammer and sparkles emoji to the terminal output. Suppressed the Vagrant not installed log warning. Updated requests to 2.25.1 in requirements.txt. Fixed a bug with the cleanup action that was corrupting git refs by ignoring modified files in the .git directory. Fixed a bug with terminal output that could cause a large empty gap of lines if build-magic is executed after running the clear command. Version 0.1.0 \u00b6 Initial release. \ud83c\udf89","title":"What's New"},{"location":"CHANGELOG/#whats-new","text":"","title":"What's New"},{"location":"CHANGELOG/#version-051-newest","text":"Fixed a cleanup action bug that prevented existing empty directories from being deleted. Updated paramiko to 2.10.1.","title":"Version 0.5.1 (Newest)"},{"location":"CHANGELOG/#version-050","text":"Added the --skip switch to manually skip named stages. Added the current working directory to stdout. Fixed a regression bug that caused the bind and hostwd parameters to fail validation. Fixed a bug introduced in 0.4.1 that would delete existing directories when the cleanup action was used.","title":"Version 0.5.0"},{"location":"CHANGELOG/#version-041","text":"Updated python packages. Fixed a cleanup action bug on Windows that prevented directories mis-identified as files from preventing cleanup. Fixed a cleanup action bug that prevented files in an empty working directory from being cleaned up. Fixed a cleanup action bug that prevented an empty directory from being deleted. Fixed a bug that would raise an unhandled exception if a Windows path was provided as a runtime variable. Fixed a cleanup action bug on Windows with the remote command runner.","title":"Version 0.4.1"},{"location":"CHANGELOG/#version-040","text":"Added a prep section to config files. Added author, maintainer, version, created, and modified sections to config files. Added the --info option to the CLI for viewing config file meta data. Added dotenv file support. Added support for environment variables. Added support for command labels to optionally display instead of the command itself. Added support for job and stage descriptions. An environment can now be specified for the Local command runner and the stage will be skipped if the environment doesn't match the current OS or distribution. Build-magic creates and uses a custom Vagrantfile when using the Vagrant command runner and setting bind directory or envvars. Bugfixes","title":"Version 0.4.0"},{"location":"CHANGELOG/#version-033","text":"Fixed a bug where an error when parsing a YAML file was not caught and handled. Code cleanup and style enforcement with Flake8.","title":"Version 0.3.3"},{"location":"CHANGELOG/#version-032","text":"Updated dependencies to newer versions.","title":"Version 0.3.2"},{"location":"CHANGELOG/#version-031","text":"Updated dependency versions. Improved the error message when Docker or Vagrant isn't installed. Fixed a bug that caused the spinner to continue running if the environment is a Docker container that cannot be found. Improved error handling in the case a Docker container cannot be found. Added a check for if a build-magic container is already running and raises an exception if so. Added a check to make sure the provided host working directory exists for the Docker and Vagrant runners.","title":"Version 0.3.1"},{"location":"CHANGELOG/#version-030","text":"Added the --template option for generating an example Config File named build-magic_template.yaml. Added support for variable substitution in Config Files using the syntax {{ VARIABLE }} which can be substituted with myhost by using the command-line option --variable VARIABLE myhost . Added the --prompt option to interactively prompt the user for a value to substitute with --prompt VARIABLE . Fixed a bug in the cleanup action that caused directories to not be properly deleted on Windows. Fixed a bug where open default config files were not being properly closed on Windows. Fixed a bug affecting commands displayed that are too long for the terminal or end in a new line character. Fixed a bug where the spinner continued to run after a keyboard interrupt was received. Fixed a bug where using the cleanup action on Windows would cause a job to fail on startup if a file or directory raised a permission error. Fixed a bug that prevented stderr from a command executed in a Docker container from being displayed properly.","title":"Version 0.3.0"},{"location":"CHANGELOG/#version-020","text":"Added the --target and -t options to execute specific config file stages by name. Added the ability to run specific config file stages by name passed as an argument if the config file has a default name of build-magic.yaml. Added a process spinner to long-running stage start up commands. Added the sequence number and total commands to the output for each command. Removed the newline character at the end of the output displayed when in verbose mode. Changed the stage end status from COMPLETE to DONE.","title":"Version 0.2.0"},{"location":"CHANGELOG/#version-011","text":"Added the hammer and sparkles emoji to the terminal output. Suppressed the Vagrant not installed log warning. Updated requests to 2.25.1 in requirements.txt. Fixed a bug with the cleanup action that was corrupting git refs by ignoring modified files in the .git directory. Fixed a bug with terminal output that could cause a large empty gap of lines if build-magic is executed after running the clear command.","title":"Version 0.1.1"},{"location":"CHANGELOG/#version-010","text":"Initial release. \ud83c\udf89","title":"Version 0.1.0"},{"location":"class_diagram/","text":"classDiagram CommandRunner o-- Local : Realizes CommandRunner o-- Remote : Realizes CommandRunner o-- Docker : Realizes CommandRunner o-- Vagrant : Realizes CommandRunner --|> Status : Returns StageFactory \"1\" --|> \"1..n\" Stage Stage \"1\" *-- \"1\" CommandRunner Stage \"1\" ..|> \"1\" MacroFactory : Calls Macro \"1..n\" <|-- \"1\" MacroFactory : Generates Stage \"1\" *-- \"1..n\" Macro Stage \"1\" *-- \"1..n\" Status Output \"1\" <|.. \"1\" Stage : Calls Output <|-- Basic : Inherits Output <|-- Silent : Inherits Output <|-- Tty : Inherits Action <|-- Default : Inherits Action <|-- Cleanup : Inherits Action <|-- Persist : Inherits CommandRunner o-- Action : Dynamically binds class CLI class StageFactory { -build(args) Stage -_build_parameters(List~Tuple~ parameters) dict -_build_command_runner(args) CommandRunner -_build_macros(List~str~ commands, List~str~ artifacts) List~Macro~ } class Stage { -Action _action -CommandRunner _command_runner -List~str~ _directives -List~Macro~ _macros -int _result -List~int~ _results +bool is_setup +int|str sequence +str name -_get_action_function(str method) Callable +setup() +run(bool continue_on_fail, bool verbose) int } class Engine { -bool _continue_on_fail -List~Stage~ _stages -bool _verbose +run() int } class Action { <<Abstract>> +dict add_prefix +dict add_suffix +dict mapping } class Default class Cleanup class Persist class CommandRunner { <<Abstract>> +str environment +str working_directory +str copy_from_directory +int timeout +List~str~ artifacts +dict parameters +str name -_filter_parameters(dict parameters, Tuple~str~ parameter_names) dict +cd(str|Path directory) bool +copy(str|Path src, str|Path dst) bool +provision() Status +prepare() +execute(Macro macro) Status +teardown() Status } class Local { +prepare() bool } class Remote { -_get_ssh_key() PKey +connect() SSHClient +copy(str|Path src, str|Path dst) bool +prepare() bool +execute(Macro macro) Status } class Docker { +prepare() bool +execute(Macro macro) Status } class Vagrant { +prepare() bool +execute(Macro macro) Status } class Macro { +str command +int|str sequence +str prefix +str suffix +as_string() str +as_list() List~str~ } class MacroFactory { -List~str~ commands +generate() List~Macro~ } class Status { +str stdout +str stderr +int exit_code -_validate(Any other)$ None +__repr__() str +__eq__(Any other) bool +__lt__(Any other) bool +__le__(Any other) bool +__gt__(Any other) bool +__ge__(Any other) bool } class Output { <<Abstract>> +datetime timer +start_job() +end_job() +no_job() +start_stage() +end_stage() +macro_start() +macro_status() +error() +info() +log(str message) +print_message(str message, bool is_error) None -display(str line, bool error)$ None } class Basic { +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start() None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Tty { -Terminal _term +get_width() int +get_height() int +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start(str directive, str command) None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Silent class EnumExt { +names() Tuple~str~ +available() Tuple~Any~ +values() Tuple~Any~ }","title":"Class diagram"},{"location":"comparison/","text":"Comparison with Similar Tools \u00b6 There are already several great automation tools out there, so why use build-magic? First of all, build-magic is primarily focused on the problem of automating build tasks. That's why it's in the name. Here's how build-magic stacks up against similar tools. Make \u00b6 Makefiles are tried and true. There's a reason they're still in use after 40+ years. Make allows a user to specify rules, targets, and commands to execute in a Makefile, in a very similar way to build-magic. Although it is primarily used for compiling files in C and C++ projects, Makefiles have found their way into command automation. While build-magic can certainly be used for compiling C and C++ projects, it isn't as focused on this as make is. Make is often a popular choice in DevOps for its ubiquity and ease of integration into pipelines. This works fine so long as Make is always executing in a Unix-like operating system, because it doesn't run on Windows. Microsoft provides nmake for Windows, which has a slightly different syntax and isn't 100% compatible with Make. Build-magic has no problem executing on Windows, MacOS, or Linux. Also, Makefiles use their own specific syntax (requiring tabs), while build-magic uses YAML, which should be familiar to anyone who's used Docker, Ansible, or most CI/CD tools. Build-magic also makes executing targets in a Docker container or virtual machine much easier compared to Make. For example, to execute several commands inside a Docker container using a Make target would involve starting a detached container, calling docker exec for each command, and finally docker stop && docker rm to stop and delete the container. Build-magic abstracts away the container management and allows the user to just worry about which commands to execute. When using Make from the command-line, only a single target can be specified. This can often lead to a situation where rules need to be created to run multiple targets in order. The syntax for this can often be confusing for newcomers. Build-magic takes the approach of running stages in the order they're defined. If more fine-grained control is needed, the order of stages can be changed at runtime, and multiple Config Files can be specified to expand the pool of available stages to specify at runtime. Makefile variables are a useful feature, considering Make executes each command in it's own shell. Build-magic makes use of YAML aliases and anchors for hard-coding variables, with the advantage that anchors can also be commands instead of just strings. Build-magic also allows for specifying variables at runtime and specifying new environment variables in addition to hard-coded variables. Make does have a few advantages over build-magic. Make can implicitly skip execution on files that haven't been modified since Make last ran. Makefiles can define rules that apply to file suffixes and patterns. Gnu Make also has some imperative programming constructs like conditional statements and the foreach loop. Shell/Batch Scripts \u00b6 Shell scripts have been used for building software for over 45 years. In fact, sometimes the fastest way to write a simple command-line tool is to knock out a quick shell script. But as the decades have rolled by, new shells have come and gone. This means old csh and ksh scripts might not run on a user's new machine. For this reason, developers and DevOps engineers often default to writing scripts with /bin/sh , forgoing modern features of newer shells in the name of compatibility. Build-magic doesn't break backwards compatibility, so older Config Files will still work with newer versions of build-magic. Shell scripts are written in an imperative programming style, compared to build-magic's declarative style. The obvious advantage shell scripts have is being able to execute conditional statements. However, this can also be a weakness as shell scripts often have to use conditional statements to check the current state of the file system before executing a command. Build-magic strives to make jobs idempotent, so that the job is executed the same way every time without side effects. If conditional statements and loops are needed for execution, a shell script can always be executed by build-magic. Ansible \u00b6 Ansible is an automation tool that simplifies configuration management. It can be used to automate most tasks that can be performed on the command-line, but it really excels at installing software. Ansible uses YAML files called Playbooks that describe what state a system should be in after running the Playbook. If the system is already in the desired state, no action is needed. This methodology works great for installing software but breaks down with building software. Often software needs to be built for a particular OS and architecture, which Ansible tries to abstract away. This forces a user to execute shell commands within Ansible, giving up it's biggest advantage. With build-magic primarily focused on build automation, a user describes exactly what commands to run, without regard to the current state of the system. Build-magic runs precisely the commands you tell it to. Ansible also is very focused on managing remote systems. This is where Ansible scales really well, as build-magic cannot run a set of commands on multiple remote machines in parallel. However, build-magic can run commands in containers and virtual machines with easy; something Ansible struggles with.","title":"Comparison with Similar Tools"},{"location":"comparison/#comparison-with-similar-tools","text":"There are already several great automation tools out there, so why use build-magic? First of all, build-magic is primarily focused on the problem of automating build tasks. That's why it's in the name. Here's how build-magic stacks up against similar tools.","title":"Comparison with Similar Tools"},{"location":"comparison/#make","text":"Makefiles are tried and true. There's a reason they're still in use after 40+ years. Make allows a user to specify rules, targets, and commands to execute in a Makefile, in a very similar way to build-magic. Although it is primarily used for compiling files in C and C++ projects, Makefiles have found their way into command automation. While build-magic can certainly be used for compiling C and C++ projects, it isn't as focused on this as make is. Make is often a popular choice in DevOps for its ubiquity and ease of integration into pipelines. This works fine so long as Make is always executing in a Unix-like operating system, because it doesn't run on Windows. Microsoft provides nmake for Windows, which has a slightly different syntax and isn't 100% compatible with Make. Build-magic has no problem executing on Windows, MacOS, or Linux. Also, Makefiles use their own specific syntax (requiring tabs), while build-magic uses YAML, which should be familiar to anyone who's used Docker, Ansible, or most CI/CD tools. Build-magic also makes executing targets in a Docker container or virtual machine much easier compared to Make. For example, to execute several commands inside a Docker container using a Make target would involve starting a detached container, calling docker exec for each command, and finally docker stop && docker rm to stop and delete the container. Build-magic abstracts away the container management and allows the user to just worry about which commands to execute. When using Make from the command-line, only a single target can be specified. This can often lead to a situation where rules need to be created to run multiple targets in order. The syntax for this can often be confusing for newcomers. Build-magic takes the approach of running stages in the order they're defined. If more fine-grained control is needed, the order of stages can be changed at runtime, and multiple Config Files can be specified to expand the pool of available stages to specify at runtime. Makefile variables are a useful feature, considering Make executes each command in it's own shell. Build-magic makes use of YAML aliases and anchors for hard-coding variables, with the advantage that anchors can also be commands instead of just strings. Build-magic also allows for specifying variables at runtime and specifying new environment variables in addition to hard-coded variables. Make does have a few advantages over build-magic. Make can implicitly skip execution on files that haven't been modified since Make last ran. Makefiles can define rules that apply to file suffixes and patterns. Gnu Make also has some imperative programming constructs like conditional statements and the foreach loop.","title":"Make"},{"location":"comparison/#shellbatch-scripts","text":"Shell scripts have been used for building software for over 45 years. In fact, sometimes the fastest way to write a simple command-line tool is to knock out a quick shell script. But as the decades have rolled by, new shells have come and gone. This means old csh and ksh scripts might not run on a user's new machine. For this reason, developers and DevOps engineers often default to writing scripts with /bin/sh , forgoing modern features of newer shells in the name of compatibility. Build-magic doesn't break backwards compatibility, so older Config Files will still work with newer versions of build-magic. Shell scripts are written in an imperative programming style, compared to build-magic's declarative style. The obvious advantage shell scripts have is being able to execute conditional statements. However, this can also be a weakness as shell scripts often have to use conditional statements to check the current state of the file system before executing a command. Build-magic strives to make jobs idempotent, so that the job is executed the same way every time without side effects. If conditional statements and loops are needed for execution, a shell script can always be executed by build-magic.","title":"Shell/Batch Scripts"},{"location":"comparison/#ansible","text":"Ansible is an automation tool that simplifies configuration management. It can be used to automate most tasks that can be performed on the command-line, but it really excels at installing software. Ansible uses YAML files called Playbooks that describe what state a system should be in after running the Playbook. If the system is already in the desired state, no action is needed. This methodology works great for installing software but breaks down with building software. Often software needs to be built for a particular OS and architecture, which Ansible tries to abstract away. This forces a user to execute shell commands within Ansible, giving up it's biggest advantage. With build-magic primarily focused on build automation, a user describes exactly what commands to run, without regard to the current state of the system. Build-magic runs precisely the commands you tell it to. Ansible also is very focused on managing remote systems. This is where Ansible scales really well, as build-magic cannot run a set of commands on multiple remote machines in parallel. However, build-magic can run commands in containers and virtual machines with easy; something Ansible struggles with.","title":"Ansible"},{"location":"examples/","text":"Build-magic Examples \u00b6 Below, you will find a collection of example build-magic use cases. If you want to run any of the examples yourself, clone the build-magic-examples repository to get started. Distributing A Python Package Converting An OpenAPI Schema To Slate With Widdershins Building And Testing A Docker Image In a Virtual Machine Automating A Machine Learning Pipeline Distributing A Python Package \u00b6 If you have a Python package you want to distribute by uploading it to the python package index ,","title":"Build-magic Examples"},{"location":"examples/#build-magic-examples","text":"Below, you will find a collection of example build-magic use cases. If you want to run any of the examples yourself, clone the build-magic-examples repository to get started. Distributing A Python Package Converting An OpenAPI Schema To Slate With Widdershins Building And Testing A Docker Image In a Virtual Machine Automating A Machine Learning Pipeline","title":"Build-magic Examples"},{"location":"examples/#distributing-a-python-package","text":"If you have a Python package you want to distribute by uploading it to the python package index ,","title":"Distributing A Python Package"},{"location":"getting_started/","text":"Getting Started \u00b6 Requirements \u00b6 Operating System: MacOS, Windows, or Linux (optional) Python 3.6+ (optional) Docker (optional) Vagrant (optional) OpenSSH The build-magic project is cross-platform and will run on all recent OS versions. If build-magic isn't installed from a binary package, Python 3.6 or greater is required. To get the most out of build-magic, it is recommended to have OpenSSH, Docker, and Vagrant installed. Installation \u00b6 MacOS \u00b6 Build-magic can be installed with Homebrew using the following commands: > brew tap cmmorrow/build-magic > brew install build-magic Note Installing using homebrew is currently very slow because the build-magic dependencies are all built from source. Windows \u00b6 A Windows installer is available for build-magic and can be downloaded from the links below: Installer Version build-magic-0.5.1_amd64_installer.exe 0.5.1 build-magic-0.5.0_amd64_installer.exe 0.5.0 build-magic-0.4.1_amd64_installer.exe 0.4.1 build-magic-0.4.0_amd64_installer.exe 0.4.0 Linux \u00b6 The easiest way to install build-magic for Linux is by installing from a package. Debian/Ubuntu/Mint \u00b6 Minimum compatible versions are Debian 10 (buster), Ubuntu 20.04 (focal fossa), or Mint Linux 19 (Tara). Package Version SHA256 Hash build-magic-0.5.1_amd64.deb 0.5.1 build-magic-0.5.1_amd64.hash build-magic-0.5.0_amd64.deb 0.5.0 build-magic-0.5.0_amd64.hash build-magic-0.4.1_amd64.deb 0.4.1 build-magic-0.4.1_amd64.hash build-magic-0.4.0_amd64.deb 0.4.0 build-magic-0.4.0_amd64.hash build-magic-0.3.3_amd64.deb 0.3.3 build-magic-0.3.3_amd64.hash build-magic-0.3.2_amd64.deb 0.3.2 build-magic-0.3.2_amd64.hash build-magic-0.3.1_amd64.deb 0.3.1 build-magic-0.3.1_amd64.hash build-magic-0.3.0_amd64.deb 0.3.0 build-magic-0.3.0_amd64.hash Instructions: Download the build-magic package from the link above using a web browser or from the command line using wget or curl . (Optional) Download the SHA256 hash file to compare with with the hash of the downloaded package. (Optional) If you downloaded the hash file, you can view the hash with cat build-magic-(version)_amd64.hash , where (version) matches the version in the downloaded hash file. Next, compare the SHA256 hash of the downloaded package with shasum -a 256 build-magic-(version)_amd64.deb . If the hash matches the content of the downloaded hash file, the package hasn't been altered since it was built. Install the downloaded package with sudo dpkg --install build-magic-(version)_amd64.deb , where (version) matches the version in the downloaded package. Fedora/CentOS/Red Hat \u00b6 Minimum compatible versions are CentOS/RHEL 7.9 and Fedora 33. Package Version SHA256 Hash build-magic-0.5.1-0.el7.9.x86_64.rpm 0.5.1 build-magic-0.5.1-0.el7.9.x86_64.hash build-magic-0.5.0-0.el7.9.x86_64.rpm 0.5.0 build-magic-0.5.0-0.el7.9.x86_64.hash build-magic-0.4.1-0.el7.9.x86_64.rpm 0.4.1 build-magic-0.4.1-0.el7.9.x86_64.hash build-magic-0.4.0-0.el7.9.x86_64.rpm 0.4.0 build-magic-0.4.0-0.el7.9.x86_64.hash build-magic-0.3.3-0.el7.9.x86_64.rpm 0.3.3 build-magic-0.3.3-0.el7.9.x86_64.hash build-magic-0.3.2-0.el7.9.x86_64.rpm 0.3.2 build-magic-0.3.2-0.el7.9.x86_64.hash Instructions: Download the build-magic package from the link above using a web browser or from the command line using wget or curl . (Optional) Download the SHA256 hash file to compare with with the hash of the downloaded package. (Optional) If you downloaded the hash file, you can view the hash with cat build-magic-(version)-0.el7.9.x86_64.hash , where (version) matches the version in the downloaded hash file. Next, compare the SHA256 hash of the downloaded package with sha256sum build-magic-(version).el7.9.x86_64.rpm . If the hash matches the content of the downloaded hash file, the package hasn't been altered since it was built. Install the downloaded package with sudo yum install build-magic-(version).el7.9.x86_64.rpm.deb , where (version) matches the version in the downloaded package. Install via pipx \u00b6 If you have Python3 installed, the recommended way to install build-magic is into an isolated environment via pipx . > pipx install build-magic Installing from PyPI \u00b6 You can install build-magic using pip with the following command: > pip install build-magic Installing from Source \u00b6 The build-magic project is written in Python. First, create a new virtual environment for development with: > python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: > source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: > git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: > git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: > gh repo clone cmmorrow/build-magic Getting The Most Out of build-magic With Optional Command Runners \u00b6 In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine. Using Docker \u00b6 To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here . Using A Virtual Machine \u00b6 Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here . Using a Remote Machine \u00b6 Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10+, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com . Basic Usage \u00b6 You can verify build-magic is install by running the following command from a command prompt: > build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#requirements","text":"Operating System: MacOS, Windows, or Linux (optional) Python 3.6+ (optional) Docker (optional) Vagrant (optional) OpenSSH The build-magic project is cross-platform and will run on all recent OS versions. If build-magic isn't installed from a binary package, Python 3.6 or greater is required. To get the most out of build-magic, it is recommended to have OpenSSH, Docker, and Vagrant installed.","title":"Requirements"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#macos","text":"Build-magic can be installed with Homebrew using the following commands: > brew tap cmmorrow/build-magic > brew install build-magic Note Installing using homebrew is currently very slow because the build-magic dependencies are all built from source.","title":"MacOS"},{"location":"getting_started/#windows","text":"A Windows installer is available for build-magic and can be downloaded from the links below: Installer Version build-magic-0.5.1_amd64_installer.exe 0.5.1 build-magic-0.5.0_amd64_installer.exe 0.5.0 build-magic-0.4.1_amd64_installer.exe 0.4.1 build-magic-0.4.0_amd64_installer.exe 0.4.0","title":"Windows"},{"location":"getting_started/#linux","text":"The easiest way to install build-magic for Linux is by installing from a package.","title":"Linux"},{"location":"getting_started/#debianubuntumint","text":"Minimum compatible versions are Debian 10 (buster), Ubuntu 20.04 (focal fossa), or Mint Linux 19 (Tara). Package Version SHA256 Hash build-magic-0.5.1_amd64.deb 0.5.1 build-magic-0.5.1_amd64.hash build-magic-0.5.0_amd64.deb 0.5.0 build-magic-0.5.0_amd64.hash build-magic-0.4.1_amd64.deb 0.4.1 build-magic-0.4.1_amd64.hash build-magic-0.4.0_amd64.deb 0.4.0 build-magic-0.4.0_amd64.hash build-magic-0.3.3_amd64.deb 0.3.3 build-magic-0.3.3_amd64.hash build-magic-0.3.2_amd64.deb 0.3.2 build-magic-0.3.2_amd64.hash build-magic-0.3.1_amd64.deb 0.3.1 build-magic-0.3.1_amd64.hash build-magic-0.3.0_amd64.deb 0.3.0 build-magic-0.3.0_amd64.hash Instructions: Download the build-magic package from the link above using a web browser or from the command line using wget or curl . (Optional) Download the SHA256 hash file to compare with with the hash of the downloaded package. (Optional) If you downloaded the hash file, you can view the hash with cat build-magic-(version)_amd64.hash , where (version) matches the version in the downloaded hash file. Next, compare the SHA256 hash of the downloaded package with shasum -a 256 build-magic-(version)_amd64.deb . If the hash matches the content of the downloaded hash file, the package hasn't been altered since it was built. Install the downloaded package with sudo dpkg --install build-magic-(version)_amd64.deb , where (version) matches the version in the downloaded package.","title":"Debian/Ubuntu/Mint"},{"location":"getting_started/#fedoracentosred-hat","text":"Minimum compatible versions are CentOS/RHEL 7.9 and Fedora 33. Package Version SHA256 Hash build-magic-0.5.1-0.el7.9.x86_64.rpm 0.5.1 build-magic-0.5.1-0.el7.9.x86_64.hash build-magic-0.5.0-0.el7.9.x86_64.rpm 0.5.0 build-magic-0.5.0-0.el7.9.x86_64.hash build-magic-0.4.1-0.el7.9.x86_64.rpm 0.4.1 build-magic-0.4.1-0.el7.9.x86_64.hash build-magic-0.4.0-0.el7.9.x86_64.rpm 0.4.0 build-magic-0.4.0-0.el7.9.x86_64.hash build-magic-0.3.3-0.el7.9.x86_64.rpm 0.3.3 build-magic-0.3.3-0.el7.9.x86_64.hash build-magic-0.3.2-0.el7.9.x86_64.rpm 0.3.2 build-magic-0.3.2-0.el7.9.x86_64.hash Instructions: Download the build-magic package from the link above using a web browser or from the command line using wget or curl . (Optional) Download the SHA256 hash file to compare with with the hash of the downloaded package. (Optional) If you downloaded the hash file, you can view the hash with cat build-magic-(version)-0.el7.9.x86_64.hash , where (version) matches the version in the downloaded hash file. Next, compare the SHA256 hash of the downloaded package with sha256sum build-magic-(version).el7.9.x86_64.rpm . If the hash matches the content of the downloaded hash file, the package hasn't been altered since it was built. Install the downloaded package with sudo yum install build-magic-(version).el7.9.x86_64.rpm.deb , where (version) matches the version in the downloaded package.","title":"Fedora/CentOS/Red Hat"},{"location":"getting_started/#install-via-pipx","text":"If you have Python3 installed, the recommended way to install build-magic is into an isolated environment via pipx . > pipx install build-magic","title":"Install via pipx"},{"location":"getting_started/#installing-from-pypi","text":"You can install build-magic using pip with the following command: > pip install build-magic","title":"Installing from PyPI"},{"location":"getting_started/#installing-from-source","text":"The build-magic project is written in Python. First, create a new virtual environment for development with: > python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: > source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: > git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: > git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: > gh repo clone cmmorrow/build-magic","title":"Installing from Source"},{"location":"getting_started/#getting-the-most-out-of-build-magic-with-optional-command-runners","text":"In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine.","title":"Getting The Most Out of build-magic With Optional Command Runners"},{"location":"getting_started/#using-docker","text":"To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here .","title":"Using Docker"},{"location":"getting_started/#using-a-virtual-machine","text":"Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here .","title":"Using A Virtual Machine"},{"location":"getting_started/#using-a-remote-machine","text":"Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10+, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com .","title":"Using a Remote Machine"},{"location":"getting_started/#basic-usage","text":"You can verify build-magic is install by running the following command from a command prompt: > build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Basic Usage"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Running a single command \u00b6 You can run a single command from the command-line with: > build-magic --verbose echo hello world The arguments to build-magic are executed as a single command and the --verbose option prints the output of the command. Changing the output format \u00b6 Build-magic's output can be changed to a more log-like appearance with the --plain option. > build-magic --verbose --plain echo hello world Using command runners \u00b6 Build-magic can run commands locally, remotely via SSH, in a Docker container, or in a VM via Vagrant. The following commands all print the same output, but are run in different environments: > build-magic --verbose echo hello world > build-magic --verbose --runner remote -e user@myhost echo hello world > build-magic --verbose --runner docker -e alpine:latest echo hello world > build-magic --verbose --runner vagrant -e Vagrantfile echo hello world Running multiple commands \u00b6 Multiple commands can be run from the command-line using the --command or -c option which takes two values, a directive and a command wrapped in quotes. Multiple commands can similarly be run from a Config File: Command-line > build-magic \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory Running commands from a Config File \u00b6 If you have a build-magic Config File named myproject.yaml , you can run the commands in the Config File with the --config or -C option: > build-magic -C myproject.yaml Running a Config File with multiple Stages \u00b6 One of the advantages of running commands from a Config File compared to the command-line is being able to run multiple Stages. A Stage is a group of commands that are run together and executed in order. By default, if a command in a Stage fails, build-magic will move on to executing commands in the next Stage. Typically, you want to batch together commands related to a particular task into a Stage. Consider the contrived example below: > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --command execute \"echo hello > file1.txt\" \\ --command execute \"echo world > file2.txt\" \\ --command build \"tar -czf myfiles.tar.gz file1.txt file2.txt\" \\ --command execute \"rm file1.txt file2.txt\" \\ --command install \"tar -xzf myfiles.tar.gz\" \\ --command test \"cat file1.txt file2.txt\" \\ --command execute \"rm file1.txt file2.txt\" \\ --command execute \"rm myfiles.tar.gz\" We can group related commands into Stages in a Config File: build-magic : - stage : name : Setup runner : docker environment : ubuntu:latest commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - stage : name : Archive runner : docker environment : ubuntu:latest commands : - build : tar -czf myfiles.tar.gz file1.txt file2.txt label : Archive the files as myfiles.tar.gz - execute : rm file1.txt file2.txt label : Delete the original files - stage : name : Un-Archive runner : docker environment : ubuntu:latest commands : - install : tar -xzf myfiles.tar.gz label : Extract the archive to the current directory - stage : name : Result runner : docker environment : ubuntu:latest commands : - test : cat file1.txt file2.txt - execute : rm file1.txt file2.txt label : Cleanup the files - execute : rm myfiles.tar.gz label : Cleanup the archive Config Files are written in YAML, using a simple syntax. Commands are grouped together into Stages. Each stage can optionally have a name , runner , description , and environment . Commands are listed with a directive first, followed by a colon ( : ), followed by the command. Directives don't have any special meaning in build-magic, but are simply descriptive. The available directives are: execute build install test deploy release Each command can optionally define a label to be displayed in the output instead of the command being executed. Naming this file example.yaml , you can run it with: > build-magic -C example.yaml --verbose A single Stage in a Config File can be run with: > build-magic --config example.yaml --target Setup Individual Stages can be executed using the --target or -t option. The Stages will be executed in the order listed on the command-line. > build-magic --config example.yaml -t Setup -t Result --verbose The last command fails because the archive file was never created. Continue on fail \u00b6 You can tell build-magic to continue executing even if a command fails by adding --continue on the command-line to continue after fails in all Stages: > build-magic -C example.yaml -t Setup -t Result --verbose --continue Code reuse with anchors \u00b6 YAML anchors and aliases can be used to reuse repeated values. In the Config File above, the command rm file1.txt file2.txt is used more than once, and the same runner and environment is used for each Stage. These values can be replaced with anchors and called with aliases. YAML anchors can be defined in a prepare section of the Config File: prepare : - &delete_files rm file1.txt file2.txt - &runner docker - &environment ubuntu:latest build-magic : - stage : name : Setup runner : *runner environment : *environment commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - stage : name : Archive runner : *runner environment : *environment commands : - build : tar -czf myfiles.tar.gz file1.txt file2.txt label : Archive the files as myfiles.tar.gz - execute : *delete_files label : Delete the original files - stage : name : Un-Archive runner : *runner environment : *environment commands : - install : tar -xzf myfiles.tar.gz label : Extract the archive to the current directory - stage : name : Result runner : *runner environment : *environment commands : - test : cat file1.txt file2.txt - execute : *delete_files label : Cleanup the files - execute : rm myfiles.tar.gz label : Cleanup the archive The execution of this Config File is identical to the previous one. Cleanup action \u00b6 Instead of using a command to manually delete files, you can use the cleanup action with --action cleanup on the command-line or action: cleanup in a Config File which will delete all new files that were created during a build-magic Stage. Command-line > build-magic \\ --name Setup \\ --runner docker \\ --environment ubuntu:latest \\ --action cleanup \\ --command execute 'echo hello > file1.txt' \\ --command execute 'echo world > file2.txt' \\ --command test 'cat file1.txt file2.txt' Config File build-magic : - stage : name : Setup runner : docker environment : ubuntu:latest action : cleanup commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - test : cat file1.txt file2.txt After running this Config File, the files file1.txt and file2.txt will be automatically deleted without touching any other files in the directory. Using environment variables \u00b6 Commands executed by build-magic can use environment variables as if the command was being executed from the shell, but they cannot set new environment variables. This is because each command is atomic and executed in it's own shell environment, so setting an environment variable in one command doesn't carry over to another. If you want to provide new environment variables for a Stage, use the environment variable key in a stage , followed by key/value pairs where each key is the name of the environment variable. For example: build-magic : - stage : environment variables : FOO : hello BAR : world commands : - execute : echo $FOO $BAR Running the Config File above named example.yaml : > build-magic -C example.yaml --verbose The equivalent command can be run solely from the command-line with: > build-magic --env FOO hello --env BAR world --verbose echo '$FOO' '$BAR' If you need to set multiple environment variables or use different environments for development vs production, you can use a dotenv file per stage : build-magic : - stage : dotenv : develop.env commands : - execute : echo $FOO $BAR In this example, the content of develop.env is: FOO = hello BAR = world Dotenv files can also be used when running commands from the command-line: > build-magic --dotenv develop.env --verbose echo '$FOO' '$BAR' Using runtime variables \u00b6 Variables can be substituted into a Config File at runtime. A special syntax is used to mark runtime variables in a Config File and the values to use are specified by the user on the command-line with the --variable or -v option. Consider the following Config File: build-magic : - stage : commands : - execute : > curl -u {{ user }}:{{ password }} https://myrepo/myproject/{{ version }} The double braces {{}} indicate a runtime variable that should be substituted at runtime. The following will substitute values into the Config File and successfully run the command: > build-magic -v user vision -v password wanda -v version 12 -C config.yaml You can see in the output that the values were substituted into the command, however, it's a bad idea to supply passwords and other secrets in clear text. Instead, you can use the --prompt option which will interactively prompt the user for input and hide what is typed. > build-magic -v user --prompt password -v version 12 -C config.yaml > password: You can see that the prompt for password doesn't print any text that is typed, and the prompted value isn't displayed in the output either. Changing the working directory \u00b6 By default, build-magic runs in the current directory, but you can override the default by specify the working directory with working directory in a Config File or --wd from the command-line. For example, the following will set the working directory to ~/myprojects/app regardless of the shell's current directory: Command-line > build-magic \\ --wd ~/myprojects/app \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : working directory : ~/myprojects/app commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory The working directory always refers to the directory where build-magic executes commands, regardless of which runner is used. For example if we execute the commands above in a Docker container, the working directory ~/myprojects/app will refer to a path in the container. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --wd ~/myprojects/app \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : runner : docker environment : ubuntu:latest working directory : ~/myprojects/app commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory Including files \u00b6 Files can be copied from another directory into the working directory using copy from directory in a Config File or the --copy option on the command-line: Command-line > build-magic \\ --copy myproject/src \\ -c execute \"go build main.go\" \\ audio.go equalizer.go effects.go Config File build-magic : - stage : copy from directory : myproject/src artifacts : - audio.go - equalizer.go - effects.go commands : - execute : go build main.go Adding metadata to Config Files \u00b6 Config Files can contain additional info that isn't used directly by build-magic, but is useful for documenting Config Files. These metadata fields are: author maintainer version created modified description Each of these fields are user definable, as build-magic doesn't enforce any constraints on their formatting. version : 0.1.0 author : The Vision created : 2021-12-12 description : An example build-magic Config File. build-magic : - stage : commands : - execute : echo hello world Viewing Config File metadata \u00b6 You can get a high-level summary of a Config File by using the --info option to view the Stage names, runtime variables, and metadata. Consider the Config File below: maintainer : Hawkeye version : 1.0.4 prepare : - &clone_repo git clone --depth 1 --branch v{{ version }} some/git/repo.git - &get_release_id > curl -s -u {{ user }}:{{ password }} api/some/git/repo/releases/v{{ version }} | jq .id > RELEASE_ID build-magic : - stage : name : debian runner : docker environment : debian:latest working directory : /app commands : - execute : apt update - install : apt install -y gcc make curl jq git - execute : *clone_repo - build : make all - test : ./myapp --help - execute : mkdir -p $HOME/myapp/usr/local/bin - execute : mkdir -p $HOME/myapp/DEBIAN - execute : cp $HOME/control $HOME/myapp/DEBIAN - execute : cp /app/myapp /$HOME/myapp/usr/local/bin - build : dpkg-deb --build $HOME/myapp - execute : *get_release_id - release : > curl -u {{ user }}:{{ password }} --data-binary @\"$HOME/myapp.deb\" -H \"Content-Type: application/octet-stream\" uploads/some/git/repo/releases/$(cat RELEASE_ID)/assets?name=myapp.deb - stage : name : centos runner : docker environment : centos:latest working directory : /app commands : - install : yum install -y rpmdevtools git - install : yum install -y epel-release - install : yum install jq - execute : *clone_repo - build : make all - test : ./myapp --help - execute : rpmdev-setuptree - execute : mkdir -p $HOME/rpmbuild/RPMS/x86_64 - execute : cp $HOME/myapp.spec $HOME/rpmbuild/SPECS - build : rpmbuild -bb --target x86_64 $HOME/rpmbuild/SPECS/myapp.spec - execute : *get_release_id - execute : ls $HOME/rpmbuild/RPMS/x86_64/* | xargs basename > NAME - release : > curl -u {{ user }}:{{ password }} --data-binary @$(ls $HOME/rpmbuild/RPMS/x86_64/*) -H \"Content-Type: application/octet-stream\" uploads/some/git/repo/releases/$(cat RELEASE_ID)/assets?name=$(cat NAME) To get a high-level summary of this Config File named myapp.yaml , simply run: > build-magic --info myapp.yaml You can get a high-level summary of multiple Config Files by passing more than one Config File path as an argument to the --info option: > build-magic --info myapp.yaml config.yaml Specifying a local environment \u00b6 Optionally, when running a Stage locally, you can specify a local environment for the Stage to run in. You might want to do this to ensure a Stage with Debian Linux specific commands doesn't run on Red Hat Enterprise Linux, or Windows Powershell commands don't run on MacOS. If the operating system (or Linux distribution) doesn't match the current machine, build-magic will skip the Stage. For example, if running CentOS Linux and specifying the local environment as debian , the Stage will be skipped: > build-magic -r local -e debian --verbose echo hello world If running MacOS and specifying windows : > build-magic -r local -e windows --verbose echo hello world However, if the the local machine matches the specified environment, the Stage will be executed. For example, if running MacOS and specifying the environment should be macos : > build-magic -r local -e macos --verbose echo hello world Default Config File names and target arguments \u00b6 If a Config File has a default name such as build-magic.yaml , you can provide a target name as an argument, similar to calling targets in a Makefile with make : > build-magic Setup You can run all Stages in a Config File using the special target all : > build-magic all The accepted default Config File names are: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml","title":"Using Build-magic"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#running-a-single-command","text":"You can run a single command from the command-line with: > build-magic --verbose echo hello world The arguments to build-magic are executed as a single command and the --verbose option prints the output of the command.","title":"Running a single command"},{"location":"user_guide/basic_usage/#changing-the-output-format","text":"Build-magic's output can be changed to a more log-like appearance with the --plain option. > build-magic --verbose --plain echo hello world","title":"Changing the output format"},{"location":"user_guide/basic_usage/#using-command-runners","text":"Build-magic can run commands locally, remotely via SSH, in a Docker container, or in a VM via Vagrant. The following commands all print the same output, but are run in different environments: > build-magic --verbose echo hello world > build-magic --verbose --runner remote -e user@myhost echo hello world > build-magic --verbose --runner docker -e alpine:latest echo hello world > build-magic --verbose --runner vagrant -e Vagrantfile echo hello world","title":"Using command runners"},{"location":"user_guide/basic_usage/#running-multiple-commands","text":"Multiple commands can be run from the command-line using the --command or -c option which takes two values, a directive and a command wrapped in quotes. Multiple commands can similarly be run from a Config File: Command-line > build-magic \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory","title":"Running multiple commands"},{"location":"user_guide/basic_usage/#running-commands-from-a-config-file","text":"If you have a build-magic Config File named myproject.yaml , you can run the commands in the Config File with the --config or -C option: > build-magic -C myproject.yaml","title":"Running commands from a Config File"},{"location":"user_guide/basic_usage/#running-a-config-file-with-multiple-stages","text":"One of the advantages of running commands from a Config File compared to the command-line is being able to run multiple Stages. A Stage is a group of commands that are run together and executed in order. By default, if a command in a Stage fails, build-magic will move on to executing commands in the next Stage. Typically, you want to batch together commands related to a particular task into a Stage. Consider the contrived example below: > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --command execute \"echo hello > file1.txt\" \\ --command execute \"echo world > file2.txt\" \\ --command build \"tar -czf myfiles.tar.gz file1.txt file2.txt\" \\ --command execute \"rm file1.txt file2.txt\" \\ --command install \"tar -xzf myfiles.tar.gz\" \\ --command test \"cat file1.txt file2.txt\" \\ --command execute \"rm file1.txt file2.txt\" \\ --command execute \"rm myfiles.tar.gz\" We can group related commands into Stages in a Config File: build-magic : - stage : name : Setup runner : docker environment : ubuntu:latest commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - stage : name : Archive runner : docker environment : ubuntu:latest commands : - build : tar -czf myfiles.tar.gz file1.txt file2.txt label : Archive the files as myfiles.tar.gz - execute : rm file1.txt file2.txt label : Delete the original files - stage : name : Un-Archive runner : docker environment : ubuntu:latest commands : - install : tar -xzf myfiles.tar.gz label : Extract the archive to the current directory - stage : name : Result runner : docker environment : ubuntu:latest commands : - test : cat file1.txt file2.txt - execute : rm file1.txt file2.txt label : Cleanup the files - execute : rm myfiles.tar.gz label : Cleanup the archive Config Files are written in YAML, using a simple syntax. Commands are grouped together into Stages. Each stage can optionally have a name , runner , description , and environment . Commands are listed with a directive first, followed by a colon ( : ), followed by the command. Directives don't have any special meaning in build-magic, but are simply descriptive. The available directives are: execute build install test deploy release Each command can optionally define a label to be displayed in the output instead of the command being executed. Naming this file example.yaml , you can run it with: > build-magic -C example.yaml --verbose A single Stage in a Config File can be run with: > build-magic --config example.yaml --target Setup Individual Stages can be executed using the --target or -t option. The Stages will be executed in the order listed on the command-line. > build-magic --config example.yaml -t Setup -t Result --verbose The last command fails because the archive file was never created.","title":"Running a Config File with multiple Stages"},{"location":"user_guide/basic_usage/#continue-on-fail","text":"You can tell build-magic to continue executing even if a command fails by adding --continue on the command-line to continue after fails in all Stages: > build-magic -C example.yaml -t Setup -t Result --verbose --continue","title":"Continue on fail"},{"location":"user_guide/basic_usage/#code-reuse-with-anchors","text":"YAML anchors and aliases can be used to reuse repeated values. In the Config File above, the command rm file1.txt file2.txt is used more than once, and the same runner and environment is used for each Stage. These values can be replaced with anchors and called with aliases. YAML anchors can be defined in a prepare section of the Config File: prepare : - &delete_files rm file1.txt file2.txt - &runner docker - &environment ubuntu:latest build-magic : - stage : name : Setup runner : *runner environment : *environment commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - stage : name : Archive runner : *runner environment : *environment commands : - build : tar -czf myfiles.tar.gz file1.txt file2.txt label : Archive the files as myfiles.tar.gz - execute : *delete_files label : Delete the original files - stage : name : Un-Archive runner : *runner environment : *environment commands : - install : tar -xzf myfiles.tar.gz label : Extract the archive to the current directory - stage : name : Result runner : *runner environment : *environment commands : - test : cat file1.txt file2.txt - execute : *delete_files label : Cleanup the files - execute : rm myfiles.tar.gz label : Cleanup the archive The execution of this Config File is identical to the previous one.","title":"Code reuse with anchors"},{"location":"user_guide/basic_usage/#cleanup-action","text":"Instead of using a command to manually delete files, you can use the cleanup action with --action cleanup on the command-line or action: cleanup in a Config File which will delete all new files that were created during a build-magic Stage. Command-line > build-magic \\ --name Setup \\ --runner docker \\ --environment ubuntu:latest \\ --action cleanup \\ --command execute 'echo hello > file1.txt' \\ --command execute 'echo world > file2.txt' \\ --command test 'cat file1.txt file2.txt' Config File build-magic : - stage : name : Setup runner : docker environment : ubuntu:latest action : cleanup commands : - execute : echo hello > file1.txt - execute : echo world > file2.txt - test : cat file1.txt file2.txt After running this Config File, the files file1.txt and file2.txt will be automatically deleted without touching any other files in the directory.","title":"Cleanup action"},{"location":"user_guide/basic_usage/#using-environment-variables","text":"Commands executed by build-magic can use environment variables as if the command was being executed from the shell, but they cannot set new environment variables. This is because each command is atomic and executed in it's own shell environment, so setting an environment variable in one command doesn't carry over to another. If you want to provide new environment variables for a Stage, use the environment variable key in a stage , followed by key/value pairs where each key is the name of the environment variable. For example: build-magic : - stage : environment variables : FOO : hello BAR : world commands : - execute : echo $FOO $BAR Running the Config File above named example.yaml : > build-magic -C example.yaml --verbose The equivalent command can be run solely from the command-line with: > build-magic --env FOO hello --env BAR world --verbose echo '$FOO' '$BAR' If you need to set multiple environment variables or use different environments for development vs production, you can use a dotenv file per stage : build-magic : - stage : dotenv : develop.env commands : - execute : echo $FOO $BAR In this example, the content of develop.env is: FOO = hello BAR = world Dotenv files can also be used when running commands from the command-line: > build-magic --dotenv develop.env --verbose echo '$FOO' '$BAR'","title":"Using environment variables"},{"location":"user_guide/basic_usage/#using-runtime-variables","text":"Variables can be substituted into a Config File at runtime. A special syntax is used to mark runtime variables in a Config File and the values to use are specified by the user on the command-line with the --variable or -v option. Consider the following Config File: build-magic : - stage : commands : - execute : > curl -u {{ user }}:{{ password }} https://myrepo/myproject/{{ version }} The double braces {{}} indicate a runtime variable that should be substituted at runtime. The following will substitute values into the Config File and successfully run the command: > build-magic -v user vision -v password wanda -v version 12 -C config.yaml You can see in the output that the values were substituted into the command, however, it's a bad idea to supply passwords and other secrets in clear text. Instead, you can use the --prompt option which will interactively prompt the user for input and hide what is typed. > build-magic -v user --prompt password -v version 12 -C config.yaml > password: You can see that the prompt for password doesn't print any text that is typed, and the prompted value isn't displayed in the output either.","title":"Using runtime variables"},{"location":"user_guide/basic_usage/#changing-the-working-directory","text":"By default, build-magic runs in the current directory, but you can override the default by specify the working directory with working directory in a Config File or --wd from the command-line. For example, the following will set the working directory to ~/myprojects/app regardless of the shell's current directory: Command-line > build-magic \\ --wd ~/myprojects/app \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : working directory : ~/myprojects/app commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory The working directory always refers to the directory where build-magic executes commands, regardless of which runner is used. For example if we execute the commands above in a Docker container, the working directory ~/myprojects/app will refer to a path in the container. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --wd ~/myprojects/app \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make build\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : runner : docker environment : ubuntu:latest working directory : ~/myprojects/app commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make build - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory","title":"Changing the working directory"},{"location":"user_guide/basic_usage/#including-files","text":"Files can be copied from another directory into the working directory using copy from directory in a Config File or the --copy option on the command-line: Command-line > build-magic \\ --copy myproject/src \\ -c execute \"go build main.go\" \\ audio.go equalizer.go effects.go Config File build-magic : - stage : copy from directory : myproject/src artifacts : - audio.go - equalizer.go - effects.go commands : - execute : go build main.go","title":"Including files"},{"location":"user_guide/basic_usage/#adding-metadata-to-config-files","text":"Config Files can contain additional info that isn't used directly by build-magic, but is useful for documenting Config Files. These metadata fields are: author maintainer version created modified description Each of these fields are user definable, as build-magic doesn't enforce any constraints on their formatting. version : 0.1.0 author : The Vision created : 2021-12-12 description : An example build-magic Config File. build-magic : - stage : commands : - execute : echo hello world","title":"Adding metadata to Config Files"},{"location":"user_guide/basic_usage/#viewing-config-file-metadata","text":"You can get a high-level summary of a Config File by using the --info option to view the Stage names, runtime variables, and metadata. Consider the Config File below: maintainer : Hawkeye version : 1.0.4 prepare : - &clone_repo git clone --depth 1 --branch v{{ version }} some/git/repo.git - &get_release_id > curl -s -u {{ user }}:{{ password }} api/some/git/repo/releases/v{{ version }} | jq .id > RELEASE_ID build-magic : - stage : name : debian runner : docker environment : debian:latest working directory : /app commands : - execute : apt update - install : apt install -y gcc make curl jq git - execute : *clone_repo - build : make all - test : ./myapp --help - execute : mkdir -p $HOME/myapp/usr/local/bin - execute : mkdir -p $HOME/myapp/DEBIAN - execute : cp $HOME/control $HOME/myapp/DEBIAN - execute : cp /app/myapp /$HOME/myapp/usr/local/bin - build : dpkg-deb --build $HOME/myapp - execute : *get_release_id - release : > curl -u {{ user }}:{{ password }} --data-binary @\"$HOME/myapp.deb\" -H \"Content-Type: application/octet-stream\" uploads/some/git/repo/releases/$(cat RELEASE_ID)/assets?name=myapp.deb - stage : name : centos runner : docker environment : centos:latest working directory : /app commands : - install : yum install -y rpmdevtools git - install : yum install -y epel-release - install : yum install jq - execute : *clone_repo - build : make all - test : ./myapp --help - execute : rpmdev-setuptree - execute : mkdir -p $HOME/rpmbuild/RPMS/x86_64 - execute : cp $HOME/myapp.spec $HOME/rpmbuild/SPECS - build : rpmbuild -bb --target x86_64 $HOME/rpmbuild/SPECS/myapp.spec - execute : *get_release_id - execute : ls $HOME/rpmbuild/RPMS/x86_64/* | xargs basename > NAME - release : > curl -u {{ user }}:{{ password }} --data-binary @$(ls $HOME/rpmbuild/RPMS/x86_64/*) -H \"Content-Type: application/octet-stream\" uploads/some/git/repo/releases/$(cat RELEASE_ID)/assets?name=$(cat NAME) To get a high-level summary of this Config File named myapp.yaml , simply run: > build-magic --info myapp.yaml You can get a high-level summary of multiple Config Files by passing more than one Config File path as an argument to the --info option: > build-magic --info myapp.yaml config.yaml","title":"Viewing Config File metadata"},{"location":"user_guide/basic_usage/#specifying-a-local-environment","text":"Optionally, when running a Stage locally, you can specify a local environment for the Stage to run in. You might want to do this to ensure a Stage with Debian Linux specific commands doesn't run on Red Hat Enterprise Linux, or Windows Powershell commands don't run on MacOS. If the operating system (or Linux distribution) doesn't match the current machine, build-magic will skip the Stage. For example, if running CentOS Linux and specifying the local environment as debian , the Stage will be skipped: > build-magic -r local -e debian --verbose echo hello world If running MacOS and specifying windows : > build-magic -r local -e windows --verbose echo hello world However, if the the local machine matches the specified environment, the Stage will be executed. For example, if running MacOS and specifying the environment should be macos : > build-magic -r local -e macos --verbose echo hello world","title":"Specifying a local environment"},{"location":"user_guide/basic_usage/#default-config-file-names-and-target-arguments","text":"If a Config File has a default name such as build-magic.yaml , you can provide a target name as an argument, similar to calling targets in a Makefile with make : > build-magic Setup You can run all Stages in a Config File using the special target all : > build-magic all The accepted default Config File names are: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml","title":"Default Config File names and target arguments"},{"location":"user_guide/cli_usage/","text":"Using the build-magic Command-line Interface \u00b6 Synopsis \u00b6 Provide Commands \u00b6 build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--description] [--env <name value>]... [--dotenv <dotenv-file>] [--skip <stage>] [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--description] [--env <name value>]... [--dotenv <dotenv-file>] [--skip <stage>] [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...] Provide Config Files \u00b6 build-magic [--fancy | --plain | --quiet] [--verbose] [--skip <stage name>] [-t | --target <stage name>]... [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... -C | --config <config-file> build-magic [--fancy | --plain | --quiet] [--verbose] [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... all | <stage name>... | [-t | --target <stage name>]... Generate a Config File Template \u00b6 build-magic --template Check Config File Info \u00b6 build-magic --info <config-file>... Usage \u00b6 There are two ways to use build-magic from the command-line. Specify commands to execute from the command line \u00b6 Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: > build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: > build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: > build-magic --copy src --command build 'make' audio.c equalizer.c effects.c Description \u00b6 --help - Prints build-magic's help text. --version - Prints the build-magic version. --description - Provides a description of the executing stage. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --skip - Optional <stage> name to skip. --env - Key/value pairs <name value> sets an environment variable to be used in the executing stage. Can be provided multiple times. --dotenv - The path to a dotenv file of environment variables to set in the executing stage. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times. Specify stages and commands to execute from a Config File \u00b6 Execute multiple stages with multiple commands using a Config File. For example: > build-magic --config my_config.yaml Alternatively, -C (uppercase c) can be used instead of --config . > build-magic -C my_config.yaml A Config File in a different directory can also be used by providing the relative or absolute path to the Config File: > build-magic --config my_project/config.yaml Multiple Config Files can be specified and they will be executed in order. > build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a Config File with the --target option. If for example, a Config File has three stages named build , test , and deploy , the deploy stage can be run on it's own with: > build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a Config File. Running tests before building can be accomplished with: > build-magic --config my_config.yaml --target test --target build Alternatively, -t can be used instead of --target . > build-magic -C my_config.yaml -t test -t build Specifically named stages can be skipped with --skip . For example, to skip the test stage but still run the build stage use: > build-magic -C my_config.yaml --skip test -t build Named stages in a Config File can also be run similar to a Makefile by specifying the stage name: > build-magic deploy However, this usage will only work if the Config File is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named Config File, use: > build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Stage names also need to be a single word. Also, a Config File must have one of the default filenames mentioned above, which also means multiple Config Files cannot be used. The Config File must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended to use the --target option instead for these reasons. It is also possible to use the --target option with a Config File that has a default filename without having to specify the Config File name with --config . For example: > build-magic --target test --target build Note If running build-magic from a directory that has a Config File with a default filename and another Config File is specified with the --config option, both Config Files will be executed with the Config File with the default filename running first. Description \u00b6 --help - Prints build-magic's help text. --version - Prints the build-magic version. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified Config File or files to execute. If <stage name> doesn't match a named stage in any of the Config Files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified. -v , --variable - A name/value pair of <var-name var-value> where the name matches a placeholder in a Config File using the syntax {{ var-name }} and the value is the value to substitute the placeholder with. --prompt - Similar to --variable but only accepts a placeholder name <prompt-name> and interactively prompts the user to input the value to be substituted. The input is hidden as to not be displayed in the shell history.","title":"Using the CLI"},{"location":"user_guide/cli_usage/#using-the-build-magic-command-line-interface","text":"","title":"Using the build-magic Command-line Interface"},{"location":"user_guide/cli_usage/#synopsis","text":"","title":"Synopsis"},{"location":"user_guide/cli_usage/#provide-commands","text":"build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--description] [--env <name value>]... [--dotenv <dotenv-file>] [--skip <stage>] [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--description] [--env <name value>]... [--dotenv <dotenv-file>] [--skip <stage>] [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...]","title":"Provide Commands"},{"location":"user_guide/cli_usage/#provide-config-files","text":"build-magic [--fancy | --plain | --quiet] [--verbose] [--skip <stage name>] [-t | --target <stage name>]... [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... -C | --config <config-file> build-magic [--fancy | --plain | --quiet] [--verbose] [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... all | <stage name>... | [-t | --target <stage name>]...","title":"Provide Config Files"},{"location":"user_guide/cli_usage/#generate-a-config-file-template","text":"build-magic --template","title":"Generate a Config File Template"},{"location":"user_guide/cli_usage/#check-config-file-info","text":"build-magic --info <config-file>...","title":"Check Config File Info"},{"location":"user_guide/cli_usage/#usage","text":"There are two ways to use build-magic from the command-line.","title":"Usage"},{"location":"user_guide/cli_usage/#specify-commands-to-execute-from-the-command-line","text":"Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: > build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: > build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: > build-magic --copy src --command build 'make' audio.c equalizer.c effects.c","title":"Specify commands to execute from the command line"},{"location":"user_guide/cli_usage/#description","text":"--help - Prints build-magic's help text. --version - Prints the build-magic version. --description - Provides a description of the executing stage. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --skip - Optional <stage> name to skip. --env - Key/value pairs <name value> sets an environment variable to be used in the executing stage. Can be provided multiple times. --dotenv - The path to a dotenv file of environment variables to set in the executing stage. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times.","title":"Description"},{"location":"user_guide/cli_usage/#specify-stages-and-commands-to-execute-from-a-config-file","text":"Execute multiple stages with multiple commands using a Config File. For example: > build-magic --config my_config.yaml Alternatively, -C (uppercase c) can be used instead of --config . > build-magic -C my_config.yaml A Config File in a different directory can also be used by providing the relative or absolute path to the Config File: > build-magic --config my_project/config.yaml Multiple Config Files can be specified and they will be executed in order. > build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a Config File with the --target option. If for example, a Config File has three stages named build , test , and deploy , the deploy stage can be run on it's own with: > build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a Config File. Running tests before building can be accomplished with: > build-magic --config my_config.yaml --target test --target build Alternatively, -t can be used instead of --target . > build-magic -C my_config.yaml -t test -t build Specifically named stages can be skipped with --skip . For example, to skip the test stage but still run the build stage use: > build-magic -C my_config.yaml --skip test -t build Named stages in a Config File can also be run similar to a Makefile by specifying the stage name: > build-magic deploy However, this usage will only work if the Config File is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named Config File, use: > build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Stage names also need to be a single word. Also, a Config File must have one of the default filenames mentioned above, which also means multiple Config Files cannot be used. The Config File must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended to use the --target option instead for these reasons. It is also possible to use the --target option with a Config File that has a default filename without having to specify the Config File name with --config . For example: > build-magic --target test --target build Note If running build-magic from a directory that has a Config File with a default filename and another Config File is specified with the --config option, both Config Files will be executed with the Config File with the default filename running first.","title":"Specify stages and commands to execute from a Config File"},{"location":"user_guide/cli_usage/#description_1","text":"--help - Prints build-magic's help text. --version - Prints the build-magic version. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified Config File or files to execute. If <stage name> doesn't match a named stage in any of the Config Files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified. -v , --variable - A name/value pair of <var-name var-value> where the name matches a placeholder in a Config File using the syntax {{ var-name }} and the value is the value to substitute the placeholder with. --prompt - Similar to --variable but only accepts a placeholder name <prompt-name> and interactively prompts the user to input the value to be substituted. The input is hidden as to not be displayed in the shell history.","title":"Description"},{"location":"user_guide/config_usage/","text":"Defining build-magic Config Files \u00b6 Synopsis \u00b6 Build-magic supports executing multiple stages as static, repeatable jobs with a Config File. A build-magic Config File is a YAML file with the following structure: author : Vision maintainer : Vision version : 1.2.3 created : 2021/12/05 modified : 2021/12/06 description : An example build-magic Config File. prepare : - &myproject /home/myproject build-magic : - stage : name : Build Project runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject environment variables : GOOS : linux GOARCH : amd64 commands : - execute : configure - build : make label : Build the project - stage : name : Run tests description : Run integration tests against a test db runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject dotenv : mydb.env continue on fail : true commands : - execute : service start mydb label : Start the test db - test : make test label : Run integration tests - execute : service stop mydb label : Shutdown the test db - stage : name : Package CentOS runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory label : Upload the package to the artifactory Description \u00b6 build-magic - The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. The name can be used as the target if explicitly executing individual stages from the command-line. description - Optional description of the stage to be displayed by the build-magic output. The description is typically longer than the stage name . runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . environment variables - A list of key/value pairs where the key is the name of the environment variable and the value is the value of the environment variable. Each environment variable is set for the duration of the stage where it's provided. dotenv - The path to a dotenv file of environment variables to set for the duration of the stage where it's provided. working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute. label - An optional description for each command in commands that will be displayed by the build-magic output instead of the command. Metadata \u00b6 As of build-magic 0.4.0, each Config File can optionally specify job-level metadata outside of the build-magic section that can be used to provide more context for the Config File. author - The Config File author. maintainer - The Config File maintainer or maintainers. version - The version number of the Config File. created - The date the Config File was created. modified - The last date the Config File was modified. description - A brief description of the job being executed in the Config File. Prepare \u00b6 As of build-magic 0.4.0, a prepare section can optionally be provided as a list of defined YAML anchors and chunks. The anchors and associated config can be used to define repetitive commands or values to make better use of code reuse. You can of course use YAML anchors anywhere in a Config File, but the prepare section is a dedicated space for these anchors that will help keep the Config File clean and easier to read.","title":"Defining Config Files"},{"location":"user_guide/config_usage/#defining-build-magic-config-files","text":"","title":"Defining build-magic Config Files"},{"location":"user_guide/config_usage/#synopsis","text":"Build-magic supports executing multiple stages as static, repeatable jobs with a Config File. A build-magic Config File is a YAML file with the following structure: author : Vision maintainer : Vision version : 1.2.3 created : 2021/12/05 modified : 2021/12/06 description : An example build-magic Config File. prepare : - &myproject /home/myproject build-magic : - stage : name : Build Project runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject environment variables : GOOS : linux GOARCH : amd64 commands : - execute : configure - build : make label : Build the project - stage : name : Run tests description : Run integration tests against a test db runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject dotenv : mydb.env continue on fail : true commands : - execute : service start mydb label : Start the test db - test : make test label : Run integration tests - execute : service stop mydb label : Shutdown the test db - stage : name : Package CentOS runner : docker environment : centos:7 working directory : *myproject parameters : bind : *myproject commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory label : Upload the package to the artifactory","title":"Synopsis"},{"location":"user_guide/config_usage/#description","text":"build-magic - The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. The name can be used as the target if explicitly executing individual stages from the command-line. description - Optional description of the stage to be displayed by the build-magic output. The description is typically longer than the stage name . runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . environment variables - A list of key/value pairs where the key is the name of the environment variable and the value is the value of the environment variable. Each environment variable is set for the duration of the stage where it's provided. dotenv - The path to a dotenv file of environment variables to set for the duration of the stage where it's provided. working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute. label - An optional description for each command in commands that will be displayed by the build-magic output instead of the command.","title":"Description"},{"location":"user_guide/config_usage/#metadata","text":"As of build-magic 0.4.0, each Config File can optionally specify job-level metadata outside of the build-magic section that can be used to provide more context for the Config File. author - The Config File author. maintainer - The Config File maintainer or maintainers. version - The version number of the Config File. created - The date the Config File was created. modified - The last date the Config File was modified. description - A brief description of the job being executed in the Config File.","title":"Metadata"},{"location":"user_guide/config_usage/#prepare","text":"As of build-magic 0.4.0, a prepare section can optionally be provided as a list of defined YAML anchors and chunks. The anchors and associated config can be used to define repetitive commands or values to make better use of code reuse. You can of course use YAML anchors anywhere in a Config File, but the prepare section is a dedicated space for these anchors that will help keep the Config File clean and easier to read.","title":"Prepare"},{"location":"user_guide/core_concepts/","text":"Core Concepts \u00b6 To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Variables Job Actions Parameters Many of these terms will look familiar if you've used Ansible, Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic. Commands \u00b6 Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make clean In this case, build-magic simply executes the make clean Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | , It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments. The build-magic Config File syntax is similar but does not require quotes around the command: commands : - execute : tar -czf myfiles.tar.gz file1.txt file2.txt - execute : rm file1.txt file2.txt Directives \u00b6 Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic on the command-line without a Directive, the execute Directive is used by default. Command Runners \u00b6 Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Command Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: Command-line > build-magic --runner docker --environment ubuntu:latest make Config File build-magic : - stage : runner : docker environment : ubuntu:latest commands : - execute : make Output Formats \u00b6 Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy : Nicely formatted text output plain : Log friendly text output quiet : No output The default Output Format is fancy which is useful when using build-magic from a TTY (terminal) application. The plain Output Format is useful if build-magic is being used from a CI/CD tool or piped to a log file where a log-like output is preferred. Output Formats can only be set as a command-line option. Working Directory \u00b6 The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory. The default Working Directory is the current directory. The Working Directory can be set from the command-line with the --wd /home/user command or in a build-magic Config File with working directory: /home/user . Stages \u00b6 A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File. Config File \u00b6 A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File. Specific stages to execute can be selected from the command line using Targets which are described below. Targets \u00b6 A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in a Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute. For example, assume you have the Config File below named build-magic.yaml : build-magic : - stage : name : unittests commands : - test : pytest - stage : name : documentation action : cleanup commands : - build : mkdocs build - deploy : mkdocs gh-deploy - stage : name : package action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* To only run the unittests stage in this Config File, use the below command: > build-magic -t unittests or if the stage name is a single word, the command can be shortened to: > build-magic unittests To run just the unittests and documentation stages, use: > build-magic -t unittests -t documentation or: > build-magic unittests documentation To swap the order of the documentation and package stages, use: > build-magic unittests package documentation All stages in the Config File can be run with: build-magic all Variables \u00b6 Variables are values that are substituted for placeholders in a Config File. Variables values and the corresponding placeholder name are specified at runtime as command-line arguments. The placeholders use a Jinja-like syntax of surrounding the placeholder name in {{ }} . The following Config File container placeholders intended for Variable substitution: build-magic : - stage : name : package runner : docker environment : ubuntu:latest commands : # Build the package - build : rpmbuild -bb $HOME/rpmbuild/SPECS/app{{ version }}.spec # Install and test the package - install : dnf install -y $HOME/rpmbuild/RPMS/noarch/app{{ version }}.rpm # Upload the package - release : scp app{{ version }}.rpm {{ user }}:{{ password }}@{{ host }} This Config File can be re-used by different users to release new versions of the app RPM package. The Variables can be assigned at runtime with the following command as an example: > build-magic -t package \\ --variable version 3 .14.15 \\ --variable host myserver \\ --variable user myuser \\ --prompt password The --variable option consists of the placeholder name followed by the value. The --prompt option will interactively prompt the user for input. This is the recommended way for providing secrets that shouldn't appear in the shell history. Note The --prompt option only works when using a TTY (terminal) interactively and will cause build-magic to hang if executed from a script. Job \u00b6 A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File. Actions \u00b6 Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage. Parameters \u00b6 Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Core Concepts"},{"location":"user_guide/core_concepts/#core-concepts","text":"To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Variables Job Actions Parameters Many of these terms will look familiar if you've used Ansible, Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic.","title":"Core Concepts"},{"location":"user_guide/core_concepts/#commands","text":"Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make clean In this case, build-magic simply executes the make clean Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | , It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments. The build-magic Config File syntax is similar but does not require quotes around the command: commands : - execute : tar -czf myfiles.tar.gz file1.txt file2.txt - execute : rm file1.txt file2.txt","title":"Commands"},{"location":"user_guide/core_concepts/#directives","text":"Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic on the command-line without a Directive, the execute Directive is used by default.","title":"Directives"},{"location":"user_guide/core_concepts/#command-runners","text":"Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Command Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: Command-line > build-magic --runner docker --environment ubuntu:latest make Config File build-magic : - stage : runner : docker environment : ubuntu:latest commands : - execute : make","title":"Command Runners"},{"location":"user_guide/core_concepts/#output-formats","text":"Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy : Nicely formatted text output plain : Log friendly text output quiet : No output The default Output Format is fancy which is useful when using build-magic from a TTY (terminal) application. The plain Output Format is useful if build-magic is being used from a CI/CD tool or piped to a log file where a log-like output is preferred. Output Formats can only be set as a command-line option.","title":"Output Formats"},{"location":"user_guide/core_concepts/#working-directory","text":"The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory. The default Working Directory is the current directory. The Working Directory can be set from the command-line with the --wd /home/user command or in a build-magic Config File with working directory: /home/user .","title":"Working Directory"},{"location":"user_guide/core_concepts/#stages","text":"A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File.","title":"Stages"},{"location":"user_guide/core_concepts/#config-file","text":"A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File. Specific stages to execute can be selected from the command line using Targets which are described below.","title":"Config File"},{"location":"user_guide/core_concepts/#targets","text":"A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in a Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute. For example, assume you have the Config File below named build-magic.yaml : build-magic : - stage : name : unittests commands : - test : pytest - stage : name : documentation action : cleanup commands : - build : mkdocs build - deploy : mkdocs gh-deploy - stage : name : package action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* To only run the unittests stage in this Config File, use the below command: > build-magic -t unittests or if the stage name is a single word, the command can be shortened to: > build-magic unittests To run just the unittests and documentation stages, use: > build-magic -t unittests -t documentation or: > build-magic unittests documentation To swap the order of the documentation and package stages, use: > build-magic unittests package documentation All stages in the Config File can be run with: build-magic all","title":"Targets"},{"location":"user_guide/core_concepts/#variables","text":"Variables are values that are substituted for placeholders in a Config File. Variables values and the corresponding placeholder name are specified at runtime as command-line arguments. The placeholders use a Jinja-like syntax of surrounding the placeholder name in {{ }} . The following Config File container placeholders intended for Variable substitution: build-magic : - stage : name : package runner : docker environment : ubuntu:latest commands : # Build the package - build : rpmbuild -bb $HOME/rpmbuild/SPECS/app{{ version }}.spec # Install and test the package - install : dnf install -y $HOME/rpmbuild/RPMS/noarch/app{{ version }}.rpm # Upload the package - release : scp app{{ version }}.rpm {{ user }}:{{ password }}@{{ host }} This Config File can be re-used by different users to release new versions of the app RPM package. The Variables can be assigned at runtime with the following command as an example: > build-magic -t package \\ --variable version 3 .14.15 \\ --variable host myserver \\ --variable user myuser \\ --prompt password The --variable option consists of the placeholder name followed by the value. The --prompt option will interactively prompt the user for input. This is the recommended way for providing secrets that shouldn't appear in the shell history. Note The --prompt option only works when using a TTY (terminal) interactively and will cause build-magic to hang if executed from a script.","title":"Variables"},{"location":"user_guide/core_concepts/#job","text":"A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File.","title":"Job"},{"location":"user_guide/core_concepts/#actions","text":"Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage.","title":"Actions"},{"location":"user_guide/core_concepts/#parameters","text":"Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Parameters"},{"location":"user_guide/runners/docker_usage/","text":"Using the Docker Command Runner \u00b6 The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch. Running Shell Commands \u00b6 The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : 'echo $TERM' Setting the Working Directory \u00b6 When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . Command-line > build-magic -r docker -e alpine --parameter hostwd /home/myproject make Config File build-magic : - stage : runner : docker environment : alpine parameters : hostwd : /home/myproject commands : - execute : make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . Command-line > build-magic -r docker -e alpine --parameter bind /app --wd /app make Config File build-magic : - stage : runner : docker environment : alpine working directory : /app parameters : bind : /app commands : make Just as with every other Command Runner, the Working Directory can be changed with the --wd option. Copying Files Into the Container \u00b6 By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : docker environment : alpine:latest copy from directory : /home/myproject working directory : /app artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' Config File build-magic : - stage : runner : docker environment : alpine:latest parameters : hostwd : /home/myproject bind : /app working directory : /app commands : - install : apk add gcc - build : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -r docker \\ -e alpine:latest \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : docker environment : alpine:latest action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. Debugging the build-magic Container \u00b6 If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : docker environment : alpine:latest action : persist commands : - execute : cp The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Using the Docker Runner"},{"location":"user_guide/runners/docker_usage/#using-the-docker-command-runner","text":"The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch.","title":"Using the Docker Command Runner"},{"location":"user_guide/runners/docker_usage/#running-shell-commands","text":"The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/docker_usage/#setting-the-working-directory","text":"When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . Command-line > build-magic -r docker -e alpine --parameter hostwd /home/myproject make Config File build-magic : - stage : runner : docker environment : alpine parameters : hostwd : /home/myproject commands : - execute : make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . Command-line > build-magic -r docker -e alpine --parameter bind /app --wd /app make Config File build-magic : - stage : runner : docker environment : alpine working directory : /app parameters : bind : /app commands : make Just as with every other Command Runner, the Working Directory can be changed with the --wd option.","title":"Setting the Working Directory"},{"location":"user_guide/runners/docker_usage/#copying-files-into-the-container","text":"By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : docker environment : alpine:latest copy from directory : /home/myproject working directory : /app artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' Config File build-magic : - stage : runner : docker environment : alpine:latest parameters : hostwd : /home/myproject bind : /app working directory : /app commands : - install : apk add gcc - build : make","title":"Copying Files Into the Container"},{"location":"user_guide/runners/docker_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -r docker \\ -e alpine:latest \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : docker environment : alpine:latest action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/docker_usage/#debugging-the-build-magic-container","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : docker environment : alpine:latest action : persist commands : - execute : cp The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Debugging the build-magic Container"},{"location":"user_guide/runners/local_usage/","text":"Using the Local Command Runner \u00b6 The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running. Running Shell Commands \u00b6 The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping on a Posix-like OS. Command-line > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL' Setting the Working Directory \u00b6 The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --wd ~/myproject make Config File build-magic : - stage : working directory : ~/myproject commands : - execute : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : action : cleanup commands : build : python setup.py sdist bdist_wheel --universal release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. Specifying a local environment \u00b6 Optionally, when running a stage locally, you can specify a local environment for the stage to run in. You might want to do this to ensure a stage with Debian Linux specific commands doesn't run on Red Hat Enterprise Linux, or Windows Powershell commands don't run on MacOS. If the operating system (or Linux distribution) doesn't match the current machine, build-magic will skip the stage. > build-magic -r local -e debian --verbose echo hello world","title":"Using the Local Runner"},{"location":"user_guide/runners/local_usage/#using-the-local-command-runner","text":"The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running.","title":"Using the Local Command Runner"},{"location":"user_guide/runners/local_usage/#running-shell-commands","text":"The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping on a Posix-like OS. Command-line > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/local_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --wd ~/myproject make Config File build-magic : - stage : working directory : ~/myproject commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/local_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : action : cleanup commands : build : python setup.py sdist bdist_wheel --universal release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/local_usage/#specifying-a-local-environment","text":"Optionally, when running a stage locally, you can specify a local environment for the stage to run in. You might want to do this to ensure a stage with Debian Linux specific commands doesn't run on Red Hat Enterprise Linux, or Windows Powershell commands don't run on MacOS. If the operating system (or Linux distribution) doesn't match the current machine, build-magic will skip the stage. > build-magic -r local -e debian --verbose echo hello world","title":"Specifying a local environment"},{"location":"user_guide/runners/remote_usage/","text":"Using the Remote Command Runner \u00b6 The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 or 11 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo hello world Optionally, the port can also be given. By default, the port SSH will use is 22. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost:2222 commands : - execute : echo hello world Running Shell Commands \u00b6 The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : ps -ef | grep python Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose -r remote -e user@myhost 'echo $SHELL' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : 'echo $SHELL' Setting the Working Directory \u00b6 The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --runner remote --environment user@myhost --wd ~/myproject make Config File build-magic : - stage : runner : remote environment : user@myhost working directory : ~/myproject commands : - execute : make Copying Files To The Remote Machine \u00b6 Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : remote environment : user@myhost copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - execute : ./configure - execute : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : remote environment : user@myhost action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage. Working with Public/Private Keypairs \u00b6 The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/.ssh/keys/id_rsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keypath : ~/.ssh/keys/id_rsa commands : - execute : echo hello world Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keytype : ecdsa keypath : ~/.ssh/id_ecdsa commands : - execute : echo hello world To use a private key protected by a passphrase, use --parameter keypass : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keytype : ecdsa keypath : ~/.ssh/id_ecdsa keypass : secret commands : - execute : echo hello world A Note on Setting Environment Variables \u00b6 By default, OpenSSH doesn't allow for environment variables to be set on a remote machine because it's a security risk. Unless sshd is explicitly configured to allow for setting environment variables on the remote machine, passing environment variables or a dotenv file through the command-line or a Config File will have no effect. More info on the process for configuring sshd to allow environment variables can be found here .","title":"Using the Remote Runner"},{"location":"user_guide/runners/remote_usage/#using-the-remote-command-runner","text":"The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 or 11 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo hello world Optionally, the port can also be given. By default, the port SSH will use is 22. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost:2222 commands : - execute : echo hello world","title":"Using the Remote Command Runner"},{"location":"user_guide/runners/remote_usage/#running-shell-commands","text":"The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : ps -ef | grep python Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose -r remote -e user@myhost 'echo $SHELL' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/remote_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --runner remote --environment user@myhost --wd ~/myproject make Config File build-magic : - stage : runner : remote environment : user@myhost working directory : ~/myproject commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/remote_usage/#copying-files-to-the-remote-machine","text":"Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : remote environment : user@myhost copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - execute : ./configure - execute : make","title":"Copying Files To The Remote Machine"},{"location":"user_guide/runners/remote_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : remote environment : user@myhost action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/remote_usage/#working-with-publicprivate-keypairs","text":"The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/.ssh/keys/id_rsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keypath : ~/.ssh/keys/id_rsa commands : - execute : echo hello world Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keytype : ecdsa keypath : ~/.ssh/id_ecdsa commands : - execute : echo hello world To use a private key protected by a passphrase, use --parameter keypass : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : keytype : ecdsa keypath : ~/.ssh/id_ecdsa keypass : secret commands : - execute : echo hello world","title":"Working with Public/Private Keypairs"},{"location":"user_guide/runners/remote_usage/#a-note-on-setting-environment-variables","text":"By default, OpenSSH doesn't allow for environment variables to be set on a remote machine because it's a security risk. Unless sshd is explicitly configured to allow for setting environment variables on the remote machine, passing environment variables or a dotenv file through the command-line or a Config File will have no effect. More info on the process for configuring sshd to allow environment variables can be found here .","title":"A Note on Setting Environment Variables"},{"location":"user_guide/runners/vagrant_usage/","text":"Using the Vagrant Command Runner \u00b6 The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby script called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner. Using a Virtual Machine Compared to a Container \u00b6 There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers. Running Shell Commands \u00b6 The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : 'echo $TERM' Setting the Working Directory \u00b6 When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host working directory and bind directory are set from the Vagrantfile with config.vm.synced_folder . See the Vagrant Synced Folders documentation for details. Note If setting the host working directory or bind directory, build-magic creates a new Vagrantfile named Vagrantfile_build_magic in the same directory as the user specified Vagrantfile. This new Vagrantfile contains the content of the user specified Vagrantfile, as well as the new config. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . Command-line > build-magic -r vagrant -e . --wd /vagrant make Config File build-magic : - stage : runner : vagrant environment : . working directory : /vagrant commands : - execute : make Copying Files Into the Virtual Machine \u00b6 By using synced folders, all files in Host Working Directory are available from the Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the virtual machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : vagrant environment : Vagrantfile copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Debugging the Virtual Machine \u00b6 If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : vagrant environment : Vagrantfile action : persist commands : - execute cp The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Using the Vagrant Runner"},{"location":"user_guide/runners/vagrant_usage/#using-the-vagrant-command-runner","text":"The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby script called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner.","title":"Using the Vagrant Command Runner"},{"location":"user_guide/runners/vagrant_usage/#using-a-virtual-machine-compared-to-a-container","text":"There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers.","title":"Using a Virtual Machine Compared to a Container"},{"location":"user_guide/runners/vagrant_usage/#running-shell-commands","text":"The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/vagrant_usage/#setting-the-working-directory","text":"When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host working directory and bind directory are set from the Vagrantfile with config.vm.synced_folder . See the Vagrant Synced Folders documentation for details. Note If setting the host working directory or bind directory, build-magic creates a new Vagrantfile named Vagrantfile_build_magic in the same directory as the user specified Vagrantfile. This new Vagrantfile contains the content of the user specified Vagrantfile, as well as the new config. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . Command-line > build-magic -r vagrant -e . --wd /vagrant make Config File build-magic : - stage : runner : vagrant environment : . working directory : /vagrant commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/vagrant_usage/#copying-files-into-the-virtual-machine","text":"By using synced folders, all files in Host Working Directory are available from the Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the virtual machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : vagrant environment : Vagrantfile copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make","title":"Copying Files Into the Virtual Machine"},{"location":"user_guide/runners/vagrant_usage/#debugging-the-virtual-machine","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : vagrant environment : Vagrantfile action : persist commands : - execute cp The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Debugging the Virtual Machine"}]}